[{"id":"448097c5389b3ecf3581bba55a8a5ad6","title":"单片机Keil编程基础及实例","content":"单片机课程中除了需要画出原理图，还要根据自己的目的给单片机编写程序。\n由于Keil是纯英文界面，不是特别友好，下面记录一些基础使用方法\n新建工程Keil窗口左上，点击Project - New uVision Project\n\n然后会弹出保存路径的对话框，任意填写即可\n\n\n\n\n\n\nTIP\n路径推荐设置为和你的Protetus工程一样的路径，这样在之后编译出来的程序就在Proteus工程目录\\Objects\\中\n\n\n\n选择好路径之后需要选择一个设备，根据你在Proteus使用的单片机型号来选择，这里选的是AT89C51\n\n这里点击OK之后会再次弹出一个Yes或者No的对话框，选 是 就行。\n\n此时左边的目录栏应该已经有东西了，点击Target 1左边的加号按钮来展开。\n再鼠标右键点击Source Group 1，选择Add new item to Group &#39;Source Group 1&#39;\n\n然后会弹出来一个创建文件的对话框，这里选择C语言，名称随意。\n\n最后点击Add，就会有输入代码的界面了\n勾选生成Hex文件功能在开始之前，需要勾选一个功能，否则代码写完不会编译成.hex文件，也就没办法导入到Proteus运行。\n点击那个类似魔术棒的按钮之后，在弹出来的窗口点击Output，然后勾选Create Hex File\n\n开始编写使用的编程语言为C语言，主要内容都和标准的C语言写法一样。\n单片机程序中会用到while循环语句，if条件语句等等相对特殊的语句，你可能会需要先对这两个做一个基本的了解\n\nif条件语句if意为“如果”，else意为“否则”。很简单，粗略解释if条件语句就是：如果XXX条件符合，那么执行YYY，否则执行ZZZ\n在代码中如下表示：\ncif (XXX) &#123;\n    YYY;\n&#125;\nelse &#123;\n    ZZZ;\n&#125;举个例子，如果满足A &#x3D;&#x3D; 10，就输出你好，否则输出大家好\ncA = 10;\nif (A == 10) &#123;\n    printf(&quot;你好&quot;);\n&#125;\nelse &#123;\n    printf(&quot;大家好&quot;);\n&#125;C 语言把任何非零和非空的值假定为true（肯定），把零或null假定为false（否定）\n\n\nwhile循环它的基本语法为\ncwhile(条件) &#123;符合条件时将要循环执行的内容&#125;在程序中如果while中设置的条件是满足的，那么就会进行循环，直到条件不满足时会停止循环，并继续执行while语句之后的代码\nC 语言把任何非零和非空的值假定为true（肯定），把零或null假定为false（否定）\n而while循环的条件若直接为true（肯定）的话就是死循环，除非终止进程，否则它会一直循环下去\n我们在单片机里面目前只需要用到死循环，所以默认使用while的时候为while(1)，while(1) {}将会一直重复大括号里的内容，直到程序进程被强制结束。\n比如我想要程序一直反复输出你好，就可以像这样：\ncwhile(1) &#123;\n    printf(&quot;你好&quot;);\n&#125;\n下面是另外一个编程语言语言中while循环的图示，语法不同，但逻辑都是一样的\n\n这个动图所展示的逻辑是 设a&#x3D;1，当a小于10的时候重复执行输出a的数值再+2\n仔细梳理一下的话还是很好理解的\n\n实例分析下面以4月12号课程中利用开关控制LED行为作为实例\n附上对应的Proteus原理图：\n\nc//以下代码中出现中文仅为了更好理解，Keil中输入中文会显示为问号\n#include &lt;reg52.h&gt;       //这一行的作用是引用头文件，表示以下内容有部分命令来自reg52.h\nsbit LED灯=P1^0;         //使用sbit定义单片机芯片上P1.0针脚为 LED灯 ，定义时仅能为P1^0\nsbit 开关=P3^0;           //使用sbit定义单片机芯片上P3.0针脚为 开关 \n\nvoid main() &#123;            //定义main函数，可以粗略理解为你想要实现的功能从这一句开始\n    while(1) &#123;           //这里使用了一个while循环，让单片机一直重复执行以下命令直到终止\n        if (开关==0) &#123;    //使用if检测开关的电平状态，这里为若为低电平则LED灯得到低电平信号\n            LED灯=0;      //同上\n        &#125;\n        else &#123;            //else指除了上面if指定的 开关==0 情况以外的所有情况\n            LED灯=1;      //指的是当SW为非0时会执行 LED灯=1,意为LED灯得到一个高电平信号\n        &#125;\n    &#125;\n&#125;上述代码中实现的是控制开关闭合或者断开发出高或者低电平来让LED灯获取高或者低电平从而达到利用开关控制LED灯的行为。代码中仅利用开关来控制LED灯的亮或灭的状态，进阶一点的话可以使开关处于闭合状态时，LED灯不停闪烁。\n#include &lt;reg52.h&gt;是通用的，可能之后的每一个程序中都要包含这一句万金油\nsbit是用来定义单片机芯片针脚的，相当于你随便定义一个关键字给某个针脚用来在程序中指定这个针脚\n","slug":"448097c5389b3ecf3581bba55a8a5ad6","date":"2024-04-13T10:50:51.000Z","categories_index":"课程","tags_index":"单片机,C语言","author_index":"Nexaris"},{"id":"c754b75a815e74ddc69143dd4e420a68","title":"单片机Proteus基础内容","content":"本文将根据头一节单片机课程内容梳理Proteus软件的使用方法以及部分注意事项\n打开程序在机房的电脑上打开Proteus的时候需要鼠标右键单击图标，选择以管理员身份运行\n\n如果直接打开软件可能会出现元件列表没有任何选项的情况\n新建项目Proteus主页点击新建工程\n在弹出来的对话框中选择名称和路径，任意位置即可，但要记得住。\n\n\n\n\n\n\nTIP\n推荐在自己的U盘中新建一个文件夹，如单片机，然后根据每一次新建的工程名称创建一个同名文件夹，并选择该路径。   Eg. 路径：F:\\单片机\\单灯闪烁；名称：单灯闪烁.pdsprj\n\n\n路径和名称填写好之后点击下一步\n创建原理图的选项默认应为从选中的模板创建原理图。，并且自动选中的DEFAULT，保持这样点击下一步\nPCB布版设计选择不创建，这也是默认选项\n固件文件同样保持默认\n最后点击完成将会自动跳转到 原理图绘制 界面。\n元件模式刚进入到原理图绘制界面的时候左侧菜单默认为元件模式，点击原理图略缩图下方的P就可以进入选择元器件的界面了\n\n在选择需要的元件之后就可以在左侧菜单中选中它，鼠标光标会变成一支笔的样式，这个时候在原理图上点击就可以开始放置。选择好位置之后，再次单击完成放置。\n\n\n下面列出几个目前课上常用的元件关键字：AT89C51\n类别 Microprocessor ICs &gt; 子类别 8051 Family \n芯片  目前所有课程实例都选用的这个\n\n\n关键字：CAP\n类别 Capacitors &gt; 子类别 Generic\n非极性电容\n\n\n关键字：CAP-ELEC\n类别 Capacitors &gt; 子类别 Generic\n极性电容\n\n\n关键字：RES\n类别 Resistors &gt; 子类别 Generic\n电阻，目前为止貌似只用过这个\n\n\n关键字：CRYSTAL\n类别 Miscellaneous\n晶振 好像是叫这个，听老师念的\n\n\n关键字：SWITCH\n类别 Switches &amp; Relays &gt; 子类别 Switches\n开关\n\n\n关键字：BUTTON\n类别 Switches &amp; Relays &gt; 子类别 Switches\n按钮\n\n\n关键字：LED-RED 或 LED-GREEN\n类别 Optoelectronics &gt; 子类别 LEDs\nLED灯，这里根据关键字选择不同颜色的\n\n\n终端模式终端模式用于放置电源，接地，目前只使用POWER（电源） , GROUND（接地）\n\n\n导入程序往单片机导入编译好的程序文件只需要双击放置好了的板子，在弹出的对话框中设置Program File的路径\n\n","slug":"c754b75a815e74ddc69143dd4e420a68","date":"2024-04-13T05:56:08.000Z","categories_index":"课程","tags_index":"单片机","author_index":"Nexaris"},{"id":"0cf4458af37e18777158807fe15efcc1","title":"首次使用Pipenv","content":"Ubuntu 23.10的情况下使用pip install -r requirements.txt时出现问题shell❯ pip3 install -r requirements.txt\nerror: externally-managed-environment\n\n× This environment is externally managed\n╰─&gt; To install Python packages system-wide, try apt install\n    python3-xyz, where xyz is the package you are trying to\n    install.\n    \n    If you wish to install a non-Debian-packaged Python package,\n    create a virtual environment using python3 -m venv path/to/venv.\n    Then use path/to/venv/bin/python and path/to/venv/bin/pip. Make\n    sure you have python3-full installed.\n    \n    If you wish to install a non-Debian packaged Python application,\n    it may be easiest to use pipx install xyz, which will manage a\n    virtual environment for you. Make sure you have pipx installed.\n    \n    See /usr/share/doc/python3.11/README.venv for more information.\n\nnote: If you believe this is a mistake, please contact your Python installation or OS distribution provider. You can override this, at the risk of breaking your Python installation or OS, by passing --break-system-packages.\nhint: See PEP 668 for the detailed specification.背后的原因目前多个Linux最新的发行版中，正在使用Python包来实现增强功能。\n这个更新是为了避免「操作系统包管理器 (如pacman、yum、apt) 和 pip 等特定于 Python 的包管理工具之间的冲突」。\n更多详情可以在官网查看：\n[Python增强提案]: \n[Python增强提案(PEP)]: https://realpython.com/python-virtual-environments-a-primer/?ref=yaolong.net\t“PEP 668 - Python base environments”\n解决方案使用pipenv\nshellsudo apt install pipenv -yPipenv是官方推荐的python包管理工具，可以实现项目之间依赖的隔离。\n虚拟环境简单来讲，虚拟环境就是隔离你项目中安装的库的一个环境。想象一下，如果想在当前电脑中做几个需要不同依赖以及不同的库的项目，而其中要求了不同版本的同一依赖，直接安装的话可能会带来意想不到的麻烦。因此，通常我们会为每一个项目都创建一个虚拟环境，以此来隔离各个项目的工作环境。\n创建虚拟环境创建自己的项目目录，在该目录下使用命令pipenv install可以创建一个虚拟的环境。默认为当前全局环境中已有的Python版本\n如果想指定创建的虚拟环境的Python版本，可以使用以下命令：\nshellpipenv --python 3.6   #指定使用Python3.6的虚拟环境\npipenv --two          #使用系统的Python2来创建虚拟环境\npipenv --three\t\t  #使用系统的Python3来创建虚拟环境\n\n#注意：以上三个参数只能单独使用。它们还具有破坏性，会删除当前的虚拟环境，然后用适当版本的虚拟环境替代当给定了一个Python版本的时候，Pipenv会自动扫描系统中能够匹配给定的Pyhton版本的Python解释器，没制定版本时，使用系统默认的Python版本。\n执行完命令，项目文件夹会生成两个文件，Pipfile``和Pipfile.lock。如果命令执行前项目目录中不存在Pipfile文件，该命令将会创建一个Pipfile文件。如果已经有Pipfile，存在则会根据这个Pipfile生成虚拟环境。\nPipfile内容解析打开Pipfile文件，可以看到如下内容：\ntoml[[source]]\nurl = &quot;https://pypi.org/simple&quot;\nverify_ssl = true\nname = &quot;pypi&quot;\n\n[packages]\njsbeautifier = &quot;==1.14.0&quot;\njsmin = &quot;==3.0.0&quot;\nloguru = &quot;==0.5.3&quot;\npycryptodome = &quot;==3.11.0&quot;\n\n[dev-packages]\n\n[requires]\npython_version = &quot;3.11&quot;\nsource 用来设置仓库地址，即从哪下载虚拟环境所需要的包\npackages用来制定项目依赖的包，即你安装了的想要引用到虚拟环境的包\ndev-packages用来指定开发环境需要的包，这类包只用于开发过程，不用于生产环境，比如单元测试相关的包，只在开发阶段有用，这样分开便于管理\nrequires中制定目标Python版本\n\nPipfile.lock文件\nPipfile.lock中记录了当前虚拟环境中安装的依赖的版本号以及哈希，以保证被次根据这些值出来的依赖都是一致的，该文件用来保证包的完整性。记住，任何情况下都不要手动修改该文件！\n项目提交时，可将Pipfile文件和Pipfile.lock一并提交，给其他开发人员克隆下载，他们可以根据此Pipfile文件运行命令pipenv install生成自己的虚拟环境。\n\n","slug":"0cf4458af37e18777158807fe15efcc1","date":"2024-04-13T05:37:44.113Z","categories_index":"Linux","tags_index":"Linux,Python","author_index":"Nexaris"},{"id":"b9663f58f18133b35bfe243f3e916a80","title":"Hello World","content":"Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub.\nQuick StartCreate a new postbash$ hexo new &quot;My New Post&quot;More info: Writing\nRun serverbash$ hexo serverMore info: Server\nGenerate static filesbash$ hexo generateMore info: Generating\nDeploy to remote sitesbash$ hexo deployMore info: Deployment\nThis is a spoiler test\n","slug":"b9663f58f18133b35bfe243f3e916a80","date":"2024-04-12T13:36:07.160Z","categories_index":"","tags_index":"","author_index":"Nexaris"}]